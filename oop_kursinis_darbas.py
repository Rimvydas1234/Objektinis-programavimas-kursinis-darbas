# -*- coding: utf-8 -*-
"""OOP kursinis darbas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eQWVG4DVAWi53A3uhF_XKSp32R3Gqz-A
"""

import csv
import unittest

# Requirement 1: Basic Calculator Class
class Calculator:
    def __init__(self):
        self._result = 0

    def add(self, x, y):
        self._result = x + y
        return self._result

    def subtract(self, x, y):
        self._result = x - y
        return self._result

    def multiply(self, x, y):
        self._result = x * y
        return self._result

    def divide(self, x, y):
        if y == 0:
            return "Cannot divide by zero"
        self._result = x / y
        return self._result

    def get_result(self):
        return self._result

# Requirement 3: Scientific Calculator Subclass
class ScientificCalculator(Calculator):
    def square(self, x):
        self._result = x ** 2
        return self._result

    def square_root(self, x):
        self._result = x ** 0.5
        return self._result

# Requirement 4: Reading from File & Writing to File
# Reading from file
def read_input_from_file(filename):
    operations = []
    with open(filename, 'r') as file:
        reader = csv.reader(file)
        for row in reader:
            operations.append((row[0], float(row[1]), float(row[2])))
    return operations

# Writing to file
def write_output_to_file(filename, output):
    with open(filename, 'w', newline='') as file:
        writer = csv.writer(file)
        for item in output:
            writer.writerow(item)

# Factory method
def create_calculator(calculator_type):
    if calculator_type == "basic":
        return Calculator()
    elif calculator_type == "scientific":
        return ScientificCalculator()
    else:
        raise ValueError("Invalid calculator type")

# Requirement 5: Testing
class TestCalculator(unittest.TestCase):
    def setUp(self):
        self.calc = Calculator()

    def test_addition(self):
        self.assertEqual(self.calc.add(5, 3), 8)
        self.assertEqual(self.calc.get_result(), 8)  # Testing encapsulation
        self.assertEqual(self.calc.add(0, 0), 0)
        self.assertEqual(self.calc.add(-5, 3), -2)

    def test_subtraction(self):
        self.assertEqual(self.calc.subtract(5, 3), 2)
        self.assertEqual(self.calc.get_result(), 2)  # Testing encapsulation
        self.assertEqual(self.calc.subtract(0, 0), 0)
        self.assertEqual(self.calc.subtract(-5, 3), -8)

    def test_multiplication(self):
        self.assertEqual(self.calc.multiply(5, 3), 15)
        self.assertEqual(self.calc.get_result(), 15)  # Testing encapsulation
        self.assertEqual(self.calc.multiply(0, 0), 0)
        self.assertEqual(self.calc.multiply(-5, 3), -15)

    def test_division(self):
        self.assertEqual(self.calc.divide(6, 3), 2)
        self.assertEqual(self.calc.get_result(), 2)  # Testing encapsulation
        self.assertEqual(self.calc.divide(0, 5), 0)
        self.assertEqual(self.calc.divide(10, 2), 5)
        self.assertEqual(self.calc.divide(5, 0), "Cannot divide by zero")

class TestScientificCalculator(unittest.TestCase):
    def setUp(self):
        self.sci_calc = ScientificCalculator()

    def test_square(self):
        self.assertEqual(self.sci_calc.square(4), 16)
        self.assertEqual(self.sci_calc.get_result(), 16)  # Testing encapsulation

    def test_square_root(self):
        self.assertEqual(self.sci_calc.square_root(16), 4.0)
        self.assertEqual(self.sci_calc.get_result(), 4.0)  # Testing encapsulation

if __name__ == '__main__':
    # Create a sample operations.csv file
    sample_operations = [
        ["add", 5, 3],
        ["subtract", 10, 4],
        ["multiply", 2, 8],
        ["divide", 9, 3],
        ["divide", 5, 0]
    ]
    with open('operations.csv', 'w', newline='') as file:
        writer = csv.writer(file)
        writer.writerows(sample_operations)

    # Example usage
    filename = 'operations.csv'
    operations = read_input_from_file(filename)

    results = []
    for operation in operations:
        op, x, y = operation
        calc = create_calculator("basic")  # Create calculator based on operation type
        if op == 'add':
            result = calc.add(x, y)
        elif op == 'subtract':
            result = calc.subtract(x, y)
        elif op == 'multiply':
            result = calc.multiply(x, y)
        elif op == 'divide':
            result = calc.divide(x, y)
        print(f"Operation: {op}, Inputs: {x}, {y}, Result: {result}")
        results.append((op, x, y, result))

    output_filename = 'results.csv'
    write_output_to_file(output_filename, results)

    # Demonstration of using inheritance
    sci_calc = create_calculator("scientific")
    sci_calc.add(2, 3)
    print(sci_calc.get_result())  # Output: 5
    sci_calc.square(4)
    print(sci_calc.get_result())  # Output: 16
    sci_calc.square_root(16)
    print(sci_calc.get_result())  # Output: 4.0

    # Run tests
    unittest.main(argv=[''], exit=False)